<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head><title>The PyEphem Manual</title>
<style type="text/css">
code { font-weight: bold }
em { font-style: normal; font-weight: normal; font-variant: small-caps;
 text-transform: lowercase }
dl.refx, ul.refx { background-color: khaki }
li { margin-top: 1ex }
dt { margin: 1ex }
dd { margin-left: 2em }
pre { margin-left: 2em; margin-right: 2em; background-color: d0d0a0 }
</style>
</head>
<body>
<h1>The PyEphem Manual</h1>

Version 2003.April.19, for PyEphem version 3.5.2b.
<p>
_TABLE_OF_CONTENTS_
<p>
The <a href="http://www.rhodesmill.org/brandon/projects/pyephem.html">PyEphem
library</a> provides <a href="http://www.python.org/">Python</a>
programmers with access to the scientific-grade astronomical routines
used by the <a href="http://www.clearskyinstitute.com/xephem/">XEphem</a>
interactive astronomical ephemeris application; its author
<a href="http://www.clearskyinstitute.com/resumes/ecdowney/resume.html">Elwood
Charles Downey</a> generously granted permission
for the PyEphem source package to include his routines.
After installing the module
(see the <tt>INSTALL</tt> file in the distribution),
you should be able to start using it with:
<pre>
import ephem
</pre>
and then trying out the examples below.
<p>
This documentation begins with a tutorial
and ends with a comprehensive reference to the objects and variables
accessible through the <tt>ephem</tt> module.
The tutorial assumes that you are familiar with astronomy
but not all of the issues surrounding astronomical calculation;
those who find its discussions tedious
will probably just want to read over its examples
to quickly familiarize themselves with how PyEphem works.

<hr>
<h2>The PyEphem Tutorial</h2>

PyEphem will compute the positions of celestial bodies on particular dates,
and can determine where in the sky they appear from any location on earth.
<p>
When using PyEphem you will usually
create instances of the bodies that interest you,
compute their position for various dates and perhaps geographic locations,
and finally print or display the result.
For example,
to determine the location and brightness of Uranus
on the night it was discovered
we simply create a <tt>Uranus</tt> object
and ask where it was on the 13th of March~1781:

<pre class=interactive>
>>> u = ephem.Uranus()
>>> u.compute('1871/3/13')
>>> print u.ra, u.dec, u.mag
7:45:45.15 21:46:15.66 5.46
>>> print ephem.constellation(u)
('Gem', 'Gemini')
</pre>

Calling <tt>compute()</tt> sets many attributes of a body,
beyond the right ascension, declination, and magnitude printed here;
see <a href="#bodyattrs">Body Attributes</a> in the reference below
for other attributes that <tt>compute()</tt> sets.
You see that measurements are formatted as an astronomer would expect:
dates are expressed as year, month, and day delimited by slashes;
right ascension as hours of arc around the celestial equator;
and declination as degrees north of the equator.
The colons between the components of an angle are a compromise ---
the more traditional 21&deg;46&prime;15.66&prime;&prime; is not possible
with the symbols on a standard computer keyboard.
<p>
This example used one body,
but you can also have several going at once.
To determine how close Neptune and Jupiter lay
as Galileo famously observed them ---
he was busy watching the Jovian moons he had discovered two years earlier
and, though Neptune had moved overnight, he dismissed it as a background star
and left its discovery to wait another two hundred years ---
we create one instance of each planet and compare their positions:

<pre class=interactive>
>>> j = ephem.Jupiter('1612/12/28')
>>> n = ephem.Neptune('1612/12/28')
>>> print j.ra, j.dec, j.mag
12:08:09.94 0:31:49.61 -1.96
>>> print n.ra, n.dec, n.mag
12:09:05.15 0:27:40.37 7.92
>>> print ephem.separation(j, n)
0:14:24.72
</pre>

Instead of creating the planets
and then calling their <tt>compute()</tt> methods,
we have taken the shortcut of providing dates as we create them;
in general, any arguments you provide when creating a planet
are used to <tt>compute()</tt> its initial position.
The <tt>separation()</tt> function
computes the angle in degrees between two bodies,
as measured by their right ascension and declination.
In this case,
the separation of 0&deg;14&prime;
was small enough to place both planets in Galileo's field of view.
<p>
You can even create several instances of the same body.
By comparing how far Mars moves in one day at perihelion versus aphelion,
we can observe its greater speed when closer to the Sun:

<pre class=interactive>
>>> def hpos(body): return body.hlong, body.hlat
>>> ma0 = ephem.Mars('1976/05/21')    # ma: mars near aphelion
>>> ma1 = ephem.Mars('1976/05/22')
>>> print ephem.separation(hpos(ma0), hpos(ma1))
0:26:11.36
>>> mp0 = ephem.Mars('1975/06/13')    # mp: mars near perihelion
>>> mp1 = ephem.Mars('1975/06/14')
>>> print ephem.separation(hpos(mp0), hpos(mp1))
0:38:05.25
</pre>

Here we wanted to measure the motion of Mars around the Sun,
but <tt>separation()</tt> normally compares
the right ascension and declination of two bodies ---
which would measure the motion of Mars across the sky
of the moving platform of our earth.
So instead of giving <tt>separation()</tt> the Mars instances themselves,
we specifically provided
the heliocentric longitude and latitude of each instance,
revealing how far Mars moved around the Sun
regardless of how this motion appeared from earth.
<p>
In general <tt>separation()</tt> can measure the angle
between any pair of spherical coordinates,
so long as the elements of each coordinate are spherical longitude
(angle around the sphere)
followed by spherical latitude
(angle above or below its equator).
Each pair should be provided as a two-item sequence like a tuple or list.
Appropriate coordinate pairs include right ascension and declination;
heliocentric longitude and latitude;
azimuth and altitude;
and even the geographic longitude and latitude of two locations on earth.

<h3>Computing With Angles</h3>

Sometimes you may want to perform computations with times and angles.
Strings like <tt>'7:45:45.15'</tt> are attractive when printed,
but cumbersome to add and multiply;
so PyEphem also makes times and angles available as floating point numbers
for more convenient use in mathematical formulae.
<p>
All angles returned by PyEphem are actually measured in radians.
Let us return to our first example above,
and examine the results in more detail:

<pre class=interactive>
>>> u = ephem.Uranus('1871/3/13')
>>> print str(u.dec)
21:46:15.66
>>> print float(u.dec)
0.379975914955
>>> print u.dec + 1
1.37997591496
</pre>

The rule is that angles become strings when printed or given to <tt>str()</tt>,
but otherwise act like Python floating point numbers.
Note that the format operator <tt>%</tt> can return either value,
depending on whether you use <tt>%s</tt> or one of the numeric formats:

<pre class=interactive>
>>> print "as a string: %s, as a float: %f" % (u.dec, u.dec)
as a string: 21:46:15.66, as a float: 0.379976
</pre>

As an example computation,
we can verify Kepler's Second Law of planetary motion ---
that a line drawn from a planet to the sun
will sweep out equal areas over equal periods of time.
We have already computed two positions for Mars near its aphelion
that are one day apart
(and defined a helpful <tt>hpos()</tt> function; see above).
We can estimate the actual distance it moved in space that day
by multiplying its angular motion in radians by its distance from the Sun:

<pre class=interactive>
>>> aph_angle = ephem.separation(hpos(ma0), hpos(ma1))
>>> aph_distance = aph_angle * ma0.sun_distance
>>> print aph_distance
0.0126911122281
</pre>

So it moved nearly 0.013~AU in a single day (about 1.9~million kilometers).
A line drawn between it and the sun would have, roughly,
filled in a triangle whose base is 0.013~AU,
whose height is the distance to the Sun,
and whose area is therefore:

<pre class=interactive>
>>> aph_area = aph_distance * ma0.sun_distance / 2.
>>> print aph_area
0.0105710807908
</pre>

According to Kepler our results should be the same
for any other one-day period for which we compute this;
we can try using the two Mars positions from near perihelion:

<pre class=interactive>
>>> peri_angle = ephem.separation(hpos(mp0), hpos(mp1))
>>> peri_distance = peri_angle * mp0.sun_distance
>>> peri_area = peri_distance * mp0.sun_distance / 2.
>>> print peri_area      # the area, to high precision, is the same!
0.0105712665517
</pre>

Despite the fact that Mars moves twenty percent faster at perihelion,
the area swept out --- to quite high precision --- is identical,
just as Kepler predicted.
Some of the tiny difference shown here
results from our having approximated sectors of its orbit as triangles;
the rest comes from the pertubations of other planets
and other small sources of irregularity in its motion.
<p>
When you use an angle in mathematical operations,
Python will return normal floats that lack the special power
of printing themselves as degrees or hours or arc.
To turn radian measures back into printable angles,
PyEphem supplies both a <tt>degrees()</tt> and an <tt>hours()</tt> function.
For example:

<pre class=interactive>
>>> print peri_angle * 2
0.0221584026149
>>> print ephem.degrees(peri_angle * 2)
1:16:10.50
</pre>

<h3>Computing With Dates</h3>

PyEphem stores dates as the number of days since noon on 1899 December~31.
While you will probably not find
the absolute value of this number very interesting,
the fact that it is counted in days
means you can move one day forward or backward
by adding or subtracting one.
The rules described above for angles hold for floats as well:
you can create them with <tt>ephem.Date()</tt>,
but after doing arithmetic on them
you must pass them back through <tt>ephem.Date()</tt>
to turn them back into dates:

<pre class=interactive>
>>> d = ephem.Date('1950/2/28')
>>> print d + 1
18321.5
>>> print ephem.Date(d + 1)
1950/3/1 00:00:00
</pre>

The <tt>ephem</tt> module provides three constants
<tt>hour</tt>, <tt>minute</tt>, and <tt>second</tt>,
which can be added or subtracted from dates
to increment or decrement them by the desired amount.
<p>
You can specify dates in several formats;
not only can the strings that specify them
use either floating point days or provide hours, minutes, and seconds,
but you can also provide the components of the date in a tuple.
Note that PyEphem does not deal with time zones ---
use the standard <tt>time</tt> module
to convert between your local time and the Universal time used by PyEphem,
which you can generate by calling <tt>gmtime()</tt>
and give the first six elements it returns to PyEphem.
The following assignments are all equivalent:

<pre class=interactive>
>>> d = ephem.Date(34530.34375)
>>> d = ephem.Date('1994/7/16.84375')
>>> d = ephem.Date('1994/7/16 20:15')
>>> d = ephem.Date((1994, 7, 16.84375))
>>> d = ephem.Date((1994, 7, 16, 20, 15, 0))
</pre>

And to complement the fact that you can specify dates as a tuple,
two methods are provided for extracting the date as a tuple:
<tt>triple()</tt> returns a year, month, and floating point day,
while <tt>tuple()</tt> provides everything down to floating point seconds.
After any of the above calls,
the date can be examined as:

<pre class=interactive>
>>> print 'as a float: %f\nas a string: "%s"' % (d, d)
as a float: 34530.343750
as a string: "1994/7/16 20:15:00"
>>> print d.triple()
(1994, 7, 16.84375)
>>> print d.tuple()
(1994, 7, 16, 20, 15, 0.0)
</pre>

Any PyEphem function argument that requires an angle or date
will accept any of the representations shown above;
so you could, for instance,
give a three-element tuple
directly to <tt>compute()</tt> for the date,
rather than having to pass the tuple through the
<tt>date()</tt> function before using it
(though the latter approach would also work).

<h3>Computations for Particular Observers</h3>

The examples so far have determined
the position of bodies against the background of stars,
and their location in the solar system.
But to observe a body we need to know more ---
whether it is visible from our latitude,
when it rises and sets,
and the height it achieves above our horizon.
In return for this more detailed information,
PyEphem quite reasonably demands to know our position on the earth's surface;
we can provide this through an object called an <tt>Observer</tt>:

<pre class=interactive>
>>> gatech = ephem.Observer()
>>> gatech.long, gatech.lat = '-84.39733', '33.775867'
</pre>

When the <tt>Observer</tt> is provided to <tt>compute()</tt>
instead of a date and epoch,
PyEphem has enough information
to determine where in the sky the body appears.
Fill in the <tt>date</tt> and <tt>epoch</tt> fields of the <tt>Observer</tt>
with the values you would otherwise provide to <tt>compute()</tt>;
the epoch defaults to the year 2000 if you do not set it yourself.
As an example, we can examine the 1984 eclipse of the sun from Atlanta:

<pre class=interactive>
>>> gatech.date = '1984/5/30 16:22:56'   # 12:22:56 EDT
>>> sun, moon = ephem.Sun(), ephem.Moon()
>>> sun.compute(gatech), moon.compute(gatech)
>>> print sun.alt, sun.az
70:08:38.99 122:11:25.80
>>> print moon.alt, moon.az
70:08:39.46 122:11:26.04
</pre>

For those unfamiliar with azimuth and altitude:
they describe position in the sky by measuring angle around the horizon,
then angle above the horizon.
To locate the Sun and Moon in this instance,
you would begin by facing north and then turn right 122&deg;,
bringing you almost around to the southeast
(which lies 125&deg; around the sky from north);
and by looking 70&deg; above that point on the horizon ---
fairly high, given that 90&deg; is directly overhead ---
you would find the Sun and Moon.
<p>
Eclipses are classified as <i>partial</i>
when the Moon merely takes a bite out of the Sun;
<i>annular</i>
when the Moon passes inside the disc of the sun
to leave only a brilliant ring (Latin <i>annulus</i>) visible;
and <i>total</i> when the moon is large enough to cover the Sun completely.
To classify this eclipse we must compare the size of the Sun and Moon
to the distance between them.
Since each argument to <tt>separation()</tt>
can be an arbitrary measure of spherical longitude and latitude,
we can provide azimuth and altitude:

<pre class=interactive>
>>> print ephem.separation((sun.az, sun.alt), (moon.az, moon.alt))
0:00:00.47
>>> print sun.size, moon.size, sun.size - moon.size
1892.91210938 1891.85778809 1.05432128906
</pre>

The Sun's diameter is larger by 1.05&prime;&prime;,
so placing the Moon at its center
would leave an annulus of width
1.05&prime;&prime;~/~2~= 0.52&prime;&prime;
visible around the Moon's edge.
But in fact the center of the Moon lies 0.48~arc seconds
towards one edge of the sun ---
not enough to move its edge outside the sun and make a partial eclipse,
but enough to make a quite lopsided annular eclipse,
whose annulus is 0.52&prime;&prime;~+~0.48~= 1.00&prime;&prime;
wide on one side
and a scant 0.52&prime;&prime;~-~0.48~= 0.04&prime;&prime; on the other.
<p>
The sky positions computed by PyEphem
take into account the refraction of the atmosphere,
which bends upwards the images of bodies near the horizon.
During sunset, for example, the descent of the sun appears to slow
because the atmosphere bends its image upwards as it approaches the horizon:

<pre class=interactive>
>>> gatech.date = '1984/5/31 00:00'   # 20:00 EDT
>>> sun.compute(gatech)
>>> for i in range(8):
...     old_az, old_alt = sun.az, sun.alt
...     gatech.date += ephem.minute * 5.
...     sun.compute(gatech)
...     sep = ephem.separation((old_az, old_alt), (sun.az, sun.alt))
...     print gatech.date, sun.alt, sep
1984/5/31 00:05:00 6:17:37.09 1:08:48.09
1984/5/31 00:10:00 5:21:15.89 1:08:36.34
1984/5/31 00:15:00 4:25:31.82 1:08:19.95
1984/5/31 00:20:00 3:30:34.48 1:07:56.53
1984/5/31 00:25:00 2:36:38.04 1:07:22.67
1984/5/31 00:30:00 1:44:04.88 1:06:32.21
1984/5/31 00:35:00 0:53:28.95 1:05:17.02
1984/5/31 00:40:00 0:05:38.03 1:03:28.39
</pre>

We see that the Sun's apparent angular speed
indeed decreased as it approached the horizon,
from around 1&deg;08&prime; to barely 1&deg;03&prime; each five minutes.
<p>
Since atmospheric refraction varies with temperature and pressure,
you can improve the accuracy of PyEphem
by providing these values from a local forecast,
or at least from average values for your location and season.
By default an <tt>Observer</tt> uses 15&deg;C and 1013~mB,
the values for these parameters at sea level
in the standard atmosphere model used in aviation.
Setting the pressure to zero
directs PyEphem to simply ignore atmospheric refraction.
<p>
Once PyEphem knows your location it can also work out
when bodies rise, cross your meridian, and set each day.
These computations can be fairly involved,
since planets continue their journey among the stars
even as the rotation of the earth brings them across the sky;
PyEphem has to internally re-compute their position several times
before it finds the exact circumstances of rising or setting.
But this is taken care of automatically,
leaving you to simply ask:

<pre class=interactive>
>>> print sun.set_time, sun.set_az
1984/5/31 00:40:36 297:05:57.36
</pre>

This agrees with the list of altitudes we generated above,
which placed the sun at nearly zero degrees altitude at 8:40~<em>pm</em>;
the azimuth tells us exactly where on the horizon the sun set.
You can similarly determine when and where a body rose
by checking its <tt>rise_time</tt> and <tt>rise_az</tt> variables,
and for the time and height of its transit across your meridian
with <tt>transit_time</tt> and <tt>transit_alt</tt>.
<p>
Note that these risings and settings
are those for the date you have specified in the <tt>Observer</tt>
for which you asked the body to compute its position.
If between midnight and midnight on that day
a body happens not to rise, set, or transit,
the corresponding events will simply return <tt>None</tt> for their values:

<pre class=interactive>
>>> print moon.rise_time, moon.transit_time, moon.set_time
1984/5/30 10:23:13 1984/5/30 17:36:40 None
</pre>

Remember that PyEphem counts days from one midnight UTC to the next.
If you are in another time zone you will probably want to retrieve
the risings and settings from two adjacent UTC days
and use the ones that fall around the period when you will be observing.

<h3>Loading Bodies From Catalogues</h3>

So far we have dealt with the planets, the Sun, and the Moon ---
major bodies whose orbits PyEphem already knows in great detail.
But for minor bodies, like comets and asteroids,
you must aquire and load the orbital parameters yourself.
<p>
Understand that because the major planets constantly perturb
the other bodies in the solar system, including each other,
it requires great effort ---
years of observation yielding formulae with dozens or hundreds of terms ---
to predict the position of a body accurately over decades or centuries.
For a comet or asteroid,
astronomers find it more convenient
to describe its orbit as perfect ellipse, parabola, or hyperbola,
and then issue new orbital parameters as its orbit changes.
<p>
The PyEphem home page provides links to several
<a href="pyephem.html#catalogues">online catalogues</a>
of orbital elements.
Once you have obtained elements for a particular body,
simply provide them to PyEphem's <tt>readdb()</tt> function
in <i>ephem database format</i> and the resulting object is ready to use:

<pre class=interactive>
>>> yh = ephem.readdb("C/2002 Y1 (Juels-Holvorcem),e,103.7816," +
...    "166.2194,128.8232,242.5695,0.0002609,0.99705756,0.0000," +
...    "04/13.2508/2003,2000,g  6.5,4.0")
>>> yh.compute('2003/4/11')
>>> print yh.name
C/2002 Y1 (Juels-Hol
>>> print yh.ra, yh.dec
0:22:36.80 26:48:57.47
>>> print ephem.constellation(yh), yh.mag
('And', 'Andromeda') 5.96
</pre>

(Unfortunately the library upon which PyEphem is build
truncates object names to twenty characters, as you can see.)
Each call to <tt>readdb()</tt> returns an object appropriate
for the orbit specified in the database entry;
in this case it has returned an <tt>EllipticalBody</tt>:

<pre class=interactive>
>>> print yh
&lt;ephem.EllipticalBody "C/2002 Y1 (Juels-Hol" at 0x81ae450&gt;
</pre>

For objects for which you cannot find an entry in ephem database format,
you can always create the appropriate kind of object
and then fill in its orbital parameters yourself;
<a href="#orbital-elements">see below</a> for their names and meanings.
By calling the <tt>writedb()</tt> function of a PyEphem object,
you can even get it to generate its own database entry
for archiving or distribution.
<p>
There is one other database format with which PyEphem is familiar:
the NORAD Two-Line Element format (TLE) used for earth satellites.
Here are some recent elements for the International Space Station.

<pre class=interactive>
>>> iss = ephem.readtle("ISS (ZARYA)",
...  "1 25544U 98067A   03097.78853147  .00021906  00000-0  28403-3 0  8652",
...  "2 25544  51.6361  13.7980 0004256  35.6671  59.2566 15.58778559250029")
>>> gatech.date = '2003/3/23'
>>> iss.compute(gatech)
>>> print iss.rise_time, iss.transit_time, iss.set_time
2003/3/23 00:00:44 2003/3/23 00:03:22 2003/3/23 00:06:00
</pre>

Note that earth satellites are fast movers ---
in this case rising and setting in less than six minutes!
They can therefore have multiple risings and settings each day,
and the particular ones you get from <tt>rise_time</tt> and <tt>set_time</tt>
depend on the particular time of day for which you ask.
Repeating the above query eight hours later gives complete different results:

<pre class=interactive>
>>> gatech.date = '2003/3/23 8:00'
>>> iss.compute(gatech)
>>> print iss.rise_time, iss.transit_time, iss.set_time
2003/3/23 08:03:41 2003/3/23 08:08:29 2003/3/23 08:13:16
</pre>

When calling <tt>compute()</tt> for an earth satellite
you should provide an <tt>Observer</tt>,
and not simply a date and epoch,
since its location is entirely dependent
upon the location from which you are observing.
PyEphem provides extra information about earth satellites,
beyond the ones available for other objects;
<a href="#satellite-attributes">see below</a> for details.

<h3>Fixed Objects, Precession, and Epochs</h3>

We will start with the simplest:
those for which a fixed right ascension and declination are specified.
These include stars, nebulae, global clusters, and galaxies.
One example is Polaris, the North Star,
which lies at the end of Ursa Minor's tail:
<pre class=interactive>
>>> polaris = ephem.readdb("Polaris,f|M|F7,2:31:48.704,89:15:50.72,2.02,2000")
>>> print polaris.dec
RuntimeError: field dec undefined until first compute()
</pre>
We are able to create the object successfully ---
why should asking its position raise a runtime error?
The reason is that fixed objects, like planets,
have an undefined position and magnitude
until you call their <tt>compute()</tt> method
to determine their position for a particular date or <tt>Observer</tt>:
<pre class=interactive>
>>> polaris.compute()    # uses the current time by default
>>> print polaris.dec
89:15:50.73
>>> print ephem.degrees(ephem.degrees('90') - polaris.dec)
0:44:09.27
</pre>
Much better; we see that the `North Star` lies
less than forty-five arc minutes from the pole.
But why should we have to call <tt>compute()</tt>
for something fixed ---
something whose position is considered permanent,
and which should not move between one date and another?
<p>
The reason is that, while `fixed` stars and nebulae
are indeed nearly motionless over the span of human civilization,
the coordinate system by which we designate their positions
changes more rapidly.
Right ascension and declination are based
upon the orientation of the earth's pole ---
but it turns out that the pole slowly revolves
(around the axis of the ecliptic plane)
like the axis of a whirling top,
completing each revolution in roughly 25,800 years.
This motion is called <i>precession</i>.
Because this makes the entire coordinate system shift slightly every year,
is not sufficient to state that Polaris lies at
2h31m right ascension and 89:15&deg; declination;
you have to say in <i>which year</i>.
<p>
That is why the Polaris entry above ends with <tt>2000</tt> ---
this gives the year for which the coordinates are correct,
called the <i>epoch</i> of the coordinates.
Because the year 2000 is currently a very popular epoch
for quoting positions and orbital parameters,
<tt>compute()</tt> uses it by default;
but we can provide an <tt>epoch=</tt> keyword parameter
to have the coordinates translated into those for another year:
<pre class=interactive>
>>> polaris.compute(epoch='2100')
>>> print polaris.dec
89:32:26.08
</pre>
Thus we see that in another hundred years Polaris
will actually lie closer to the pole that it does today.
(The <tt>'2100'</tt> is the same year/month/day format you have seen already,
missing both its month and day
because we are not bothering to be that specific.)
If you enter subsequent years you will find
that 2100 is very nearly the closest approach of the pole to Polaris,
and that soon afterwards they move apart.
For much of the twenty-five thousand year journey the pole makes,
there are no stars very near;
we may have been lucky to have held the Age of Exploration
as the pole was approaching as convenient a star as Polaris.
<p>
Today a dim star in Draco named Thuban
lies more than twenty degrees from the pole:
<pre class=interactive>
>>> thuban = ephem.readdb("Thuban,f|V|A0,14:4:23.3,64:22:33,3.65,2000")
>>> thuban.compute()
>>> print thuban.dec
64:22:32.99
</pre>
But in 2801~<em>BC</em> as the Egyptians built the pyramids,
Thuban served as their pole star,
while Polaris lay further from their pole than Thuban lies from ours today:
<pre class=interactive>
>>> thuban.compute(epoch='-2800')
>>> print thuban.dec
89:54:34.97
>>> polaris.compute(epoch='-2800')
>>> print polaris.dec
63:33:17.63
</pre>
Realize that in these examples I have been lazy
by giving <tt>compute()</tt> an epoch without an actual date,
which requests the <i>current</i> position of each star
in the coordinates of another epoch.
This makes no difference for these fixed objects,
since their positions never change;
but when dealing with moving objects
one must always keep in mind the difference
between the date for which you want their position computed,
and the epoch in which you want those coordinates expressed.
Here are some example <tt>compute()</tt> calls,
beginning with one like the above but for a moving object:
<ul>
<li><code>halley.compute(epoch='1066')</code>
 is probably useless:
 it computes the current position of <tt>halley</tt>,
 but returns coordinates relative
 to the direction the earth's axis pointed in the year~1066.
 Unless you use a Conquest-era star atlas, this is not useful.
<li><code>halley.compute('1066', epoch='1066')</code>
 is slightly more promising:
 it computes the position of <tt>halley</tt> in 1066
 and returns coordinates for the orientation of the earth in that year.
 This might help you visualize
 how the object was positioned above contemporary observers,
 who considered it an ill omen in the imminent conflict
 between King Harold of England and William the Bastard.
 But to plot this position against a background of stars,
 you would first have to recompute each star's position in 1066 coordinates.
<li><code>halley.compute('1066')</code>
 is what you will probably use most often;
 you get the position of <tt>halley</tt> in the year 1066
 but expressed in the 2000 coordinates that your star atlas probably uses.
</ul>
When planning to observe with an equatorial telescope,
you may want to use the current date as your epoch,
because the rotation of the sky above your telescope
is determined by where the pole points today,
not where it pointed in 2000 or some other convenient epoch.
Computing positions in the epoch of their date
is accomplished by simply providing the same argument for both date and epoch:
<pre class=interactive>
>>> j = ephem.Jupiter()
>>> j.compute(epoch=ephem.now())   # so both date and epoch are now
>>> print j.ra, j.dec
8:44:29.49 19:00:10.23
>>> j.compute('2003/3/25', epoch='2003/3/25')
>>> print j.ra, j.dec
8:43:32.82 19:03:32.46
</pre>
Be careful when computing distances;
comparing two positions in the coordinates of their own epochs
will give slightly different results
than if the two were based on the same epoch:
<pre class=interactive>
>>> j1, j2 = ephem.Jupiter(), ephem.Jupiter()
>>> j1.compute('2003/3/1')
>>> j2.compute('2003/4/1')
>>> print ephem.separation(j1, j2)    # coordinates are both epoch 2000
1:46:35.85
>>> j1.compute('2003/3/1', '2003/3/1')
>>> j2.compute('2003/4/1', '2003/4/1')
>>> print ephem.separation(j1, j2)    # coordinates are both epoch-of-date
1:46:31.56
</pre>
Comparing coordinates of the same epoch, as in the first call,
measures motion against the background of stars;
comparing coordinates from different epochs, as in the second call,
measures motion against the slowly shifting coordinate system of the earth.
Users are most often interested in the first kind of measurement,
and stick with a single epoch the whole way through a computation.
<p>
It was for the sake of simplicity
that all of the examples in this section
simply provided dates as arguments to the <tt>compute()</tt> function.
If you are instead using an <tt>Observer</tt> argument,
then you specify the epoch through the observer's <tt>epoch</tt> variable,
not through the <tt>epoch=</tt> argument.
Observers use epoch 2000 by default.
<p>
Finally,
make sure you understand
that your choice of epoch only affects absolute position ---
the right ascension and declination returned for objects ---
<i>not</i> the azimuth and altitude of an object above an observer.
This is because the sun will hang in the same position over Atlanta
whether the star atlas with which you plot its position
has epoch 2000, or 1950, or even~1066 coordinates;
the epoch only affects how you name locations in the sky,
not how they are positioned with respect to you.

<hr>
<h2>The PyEphem Reference</h2>

<h3>1. Module Contents.</h3>

<dl class=ref>
<dt>
<code>Sun()
Moon()
Mercury()
Venus()
Mars()
Jupiter()
Saturn()
Uranus()
Neptune()
Pluto()</code>
<dd>
Each of these functions creates and returns
an instance of a major solar-system body,
whose position XEphem already knows how to compute
using high accuracy formulae and series.
<dt>
<code>readdb(<i>line</i>)</code>
<dd>
This function accepts an entry from an XEphem database file
and returns an object representing it.
Problems parsing the line result in a <tt>ValueError</tt> being raised.
Its type will be one of the following five,
with all relevant orbital elements already set.
<dt>
<code>readtle(<i>name</i>, <i>line1</i>, <i>line2</i>)</code>
<dd>
This function parses an earth satellite description
that is in the Two-Line Element format used by NORAD.
The resulting object will be an <tt>EarthSatellite</tt>.
<dt>
<code>FixedBody()
 EllipticalBody() ParabolicBody() HyperbolicBody()
 EarthSatellite()</code>
<dd>
These create blank and uninitialized bodies
whose orbital elements you must set before using them;
<a href="#orbital-elements">see below</a>
for the orbital elements required for each type of body.
<dt><code>constellation(<i>body</i>)</code>
<br><code>constellation((<i>ra</i>, <i>dec</i>))</code>
<br><code>constellation((<i>ra</i>, <i>dec</i>), epoch=<i>epoch</i>)</code>
<dd>
Determines the constellation in which the given body or coordinates lie.
If you provide coordinates without an epoch,
then epoch 2000 is assumed.
<dt>
<code>separation(<i>position0</i>, <i>position1</i>)</code>
<dd>
Returns the angle in degrees between two positions on a sphere.
Each position should be a coordinate pair
whose first element measures angle around the sphere's equator,
and whose second specifies angle above or below its equator.
(Common examples of such pairs are right ascension and declination,
and longitude and latitude.)
While each coordinate pair can simply be a sequence of two floats,
you can also submit an <tt>Observer</tt>,
whose longitude and latitude will be used,
or a celestial body,
whose right ascension and declination will be used.
</dl>

<h3>2. Angles and Times</h3>

Every <tt>ephem</tt> object and method that returns an angle
will return a floating point number
giving the angle in radians,
but which if subjected to either <tt>str()</tt> or to printing
will format itself as traditional degrees or hours of right ascension
like <tt>'7:45:45.15'</tt>.
But since any mathematics performed upon an angle
will return a normal Python float,
the following functions are useful:

<dl>
<dt><code>degrees(<i>radians_float</i>)</code>
<br><code>degrees(<i>degrees_string</i>)</code>
<dd>
Returns a floating point number of radians
which formats itself as degrees of arc
when printed or subjected to <tt>str()</tt>.
It can be initialized directly with a float in radians,
or with a string expressing degrees
in sexigesimal format like <tt>'33:44:56'</tt>
or as a decimal like <tt>'33.7489'</tt>.
Strings produced by the angle are always sexigesimal.
<dt><code>hours(<i>radians_float</i>)</code>
<br><code>hours(<i>hours_string</i>)</code>
<dd>
Like the above function except that the string taken as input,
returned by <tt>str()</tt>, or printed,
uses hours of arc (of which there are twenty-four in a circle).
</dl>

Dates are stored as the number of days since noon on 1899 December~31,
and like angles yield simple floats when used in computations.
They can be created by the <tt>date</tt> function
using several techniques and formats:

<dl>
<dt><code>date(<i>raw_float</i>)</code>
<br><code>date('<i>yyyy.y</i>')</code>
<!-- <br><code>date('<i>yyyy/mm.m</i>')</code> -->
<br><code>date('<i>yyyy/mm/dd.d</i>')</code>
<br><code>date('<i>yyyy/mm/dd hh.h</i>')</code>
<br><code>date('<i>yyyy/mm/dd hh/mm.m</i>')</code>
<br><code>date('<i>yyyy/mm/dd hh/mm/ss.s</i>')</code>
<br><code>date((<i>yyyy</i>,))</code>
<br><code>date((<i>yyyy</i>, <i>mm</i>))</code>
<br><code>date((<i>yyyy</i>, <i>mm</i>, <i>dd.d</i>))</code>
<br><code>date((<i>yyyy</i>, <i>mm</i>, <i>dd</i>, <i>hh.h</i>))</code>
<br><code>date((<i>yyyy</i>, <i>mm</i>, <i>dd</i>, <i>hh</i>,
 <i>mm.m</i>))</code>
<br><code>date((<i>yyyy</i>, <i>mm</i>, <i>dd</i>,
 <i>hh</i>, <i>mm</i>, <i>ss.s</i>))</code>
</dl>

In addition to using dates as floats,
and as strings through <tt>str()</tt> and <tt>print</tt>,
they can be extracted in two other forms:

<p>
<code><i>date</i>.triple()</code> ---
Returns the date as <tt>(<i>year</i>, <i>month</i>, <i>day.fraction</i>)</tt>.
<br><code><i>date</i>.tuple()</code> ---
Returns the date as <tt>(<i>year</i>, <i>month</i>, <i>day</i>,
 <i>hour</i>, <i>minute</i>, <i>second.fraction</i>)</tt>.
<p>

Three constants are provided to help increment and decrement dates:

<p>
<code>hour</code> = one twenty-fourth
<br><code>minute</code> = one sixtieth of an hour
<br><code>second</code> = one sixtieth of a minute

<h3>3. Observer Objects</h3>

Default values are shown in parenthesis.
<p>
<code><i>observer</i>.date</code> --- the date for which the position
 should be computed (current time)
<br><code><i>observer</i>.epoch</code> --- epoch for which coordinates
 should be generated (year~2000)
<br><code><i>observer</i>.long,
 <i>observer</i>.lat</code> --- location of the observer on the earth 
<br><code><i>observer</i>.elev</code> --- elevation above sea level in meters
 (0~m)
<br><code><i>observer</i>.temp</code> --- temperature in degrees centigrade
 (15&deg;C)
<br><code><i>observer</i>.pressure</code> --- atmospheric pressure in milibars
 (1013~mB)
<p>
The <tt>temp</tt> and <tt>pressure</tt> are used
to estimate how the object's position will be distorted by the atmosphere
when it is close to the horizon;
setting <tt>pressure</tt> to zero makes PyEphem ignore atmospheric refraction.

<h3>4. Body Methods</h3>

<dl class=ref>
<dt>
<code><i>body</i>.compute()
<br><i>body</i>.compute(<i>date</i>)
<br><i>body</i>.compute(epoch=<i>epoch</i>)
<br><i>body</i>.compute(<i>date</i>, epoch=<i>epoch</i>)
<br><i>body</i>.compute(<i>observer</i>)
<br></code>
<dd>Computes the position of the body for a particular date
and in the equatorial coordinates of a particular epoch,
and stores the result in the attributes listed above.
The first four forms are <i>geocentric</i>
and determine the object's position from the center of the earth;
if <tt><i>date</i></tt> is not specified, the current time is used,
while an unspecified <tt><i>epoch</i></tt> defaults to year-2000.
The last form is <i>topocentric</i> and determines the object's position
above the particular location on the earth's surface
specified by the <tt><i>observer</i></tt>,
and for the time and epoch it specifies.
<dt>
<code><i>body</i>.writedb()</code>
<dd>
This returns a string representing the object in ephem database format;
you can recreate the object at any later time
by submitting this string to the module's <tt>readdb()</tt> function.
</dl>

<h3>5. Body Attributes</h3>

<a name="bodyattrs">These attributes</a>
store the results of the most recent <tt>compute()</tt>
that you have performed on a body;
before the first call, most of these values are zero.

<dl>
<dt><b>Absolute Position</b>
(always computed)
<dd><code><i>body</i>.ra, <i>body</i>.dec</code> --- equatorial coordinates
 in hours of right ascension and degrees of declination
<br><code><i>body</i>.elong</code> --- angle in degrees
 between the position of the sun and the body
<br><code><i>body</i>.mag</code> --- visual magnitude
<br><code><i>body</i>.size</code> --- visual size of object in arc seconds

<dt><b>Position for an Observer</b>
(computed when an <tt>Observer</tt> is provided to <tt>compute()</tt>)
<dd><code><i>body</i>.az, <i>body</i>.alt</code>
 --- position in the sky for the observer,
 measured in degrees azimuth east of north,
 and degrees altitude above the horizon
<br><code><i>body</i>.apparent_ra, <i>body</i>.apparent_dec</code>
 --- the apparent position of the object,
 in hours of right ascension and degrees of declination,
 when viewed by an observer through the distorting lens of the atmosphere
 (which typically raises the altitude of objects near the edge of the horizon)
<br>
<br><code><i>body</i>.rise_time, <i>body</i>.rise_az,
<br><i>body</i>.transit_time, <i>body</i>.transit_alt,
<br><i>body</i>.set_time, <i>body</i>.set_az</code>
<br>--- these attributes establish when and where the object rises,
transits, and sets on the day for which its position has been computed.
Note when accessing these attributes
that their computation can be expensive,
since they must recompute the object's position
for several other times during the day.

<dt><b>Solar System Position</b>
(available for all objects that orbit the sun)
<dd><code><i>body</i>.hlong, <i>body</i>.hlat</code> --- heliocentric
 position given in degrees of longitude and latitude
<br><code><i>body</i>.sun_distance</code> --- distance from the sun in~AU
<br><code><i>body</i>.earth_distance</code> --- distance from earth in~AU
<br><code><i>body</i>.phase</code> --- percent of the body illuminated
 when viewed from earth

<dt><b>Moon Attributes</b>
<dd><code><i>body</i>.phase</code> --- the fraction of the lunar surface
 that appears illuminated from the earth
<br><code><i>body</i>.colong</code> ---
 the <i>selenographic colongitude</i>,
 the lunar longitude experiencing sunrise
<br><code><i>body</i>.subsolar_lat</code> --- the lunar latitude
 of the location where the sun is directly overhead
<br><code><i>body</i>.libration_lat</code> --- the longitude of the
 point on the lunar surface facing the earth
<br><code><i>body</i>.libration_long</code> --- the degrees by which
 the point on the moon facing us is east or west 

<dt><b>Saturn Attributes</b>
<dd><code><i>body</i>.earth_tilt, <i>body</i>.sun_tilt</code> ---
 the degrees southward by which Saturn's rings are tilted
 when Saturn is viewed respectively from the earth and from the sun
<br><code>

<dt><a name="satellite-attributes"><b>Satellite Attributes</b></a>
<dd><code><i>body</i>.sublat, <i>body</i>.sublong</code> ---
 the degrees latitude and longitude of the point on earth
 above which the satellite is positioned
<br><code><i>body</i>.elevation</code> --- the height of the satellite
 above sea level in meters
<br><code><i>body</i>.range</code> --- the distance in meters
 between the observer and the satellite
<br><code><i>body</i>.range_velocity</code> --- the rate in meters per second
 at which the distance between the observer and the satellite is changing
<br><code><i>body</i>.eclipsed</code> --- whether the satellite lies
 in the earth's shadow
</dl>

<h3>6. Orbital Elements</h3>

<a name="orbital-elements">Bodies with supplied orbital elements</a>
can be of any of the following types;
you can create such bodies
either by submitting an ephem database entry to <tt>ephem.readdb()</tt>
or by creating one of these objects directly
and filling in the properties of its orbit.
Orbital elements always begin with an underscore
to prevent their being confused with normal object attributes.

<dl class=ref>
<dt><b>Fixed Object Elements (<tt>FixedBody</tt>)</b>
<dd><code><i>body</i>._class</code> --- a character in which to store
 the classification of the fixed object
<br><code><i>body</i>._spect</code> --- a two-character string
 where you can store the spectral code
<br><code><i>body</i>._ratio</code> --- the ratio between the major
 and minor diameters
<br><code><i>body</i>._pa</code> --- the angle at which
 the major axis lies in the sky, in degrees east of north
<br><code><i>body</i>._epoch</code> --- the epoch of the position
<br><code><i>body</i>._ra, <i>body</i>._dec</code> --- position
 in hours and degrees respectively

<dt><b>Elliptical Orbital Elements (<tt>EllipticalBody</tt>)</b>
<dd><code><i>body</i>._inc</code> --- inclination in degrees
<br><code><i>body</i>._Om</code> --- longitude of ascending node in degrees
<br><code><i>body</i>._om</code> --- argument of perihelion in degrees
<br><code><i>body</i>._a</code> --- mean distance from sun in~AU
<br><code><i>body</i>._M</code> --- mean anomaly in degrees
 from perihelion at~<tt>cepoch</tt>
<br><code><i>body</i>._size</code> --- angular size in arc seconds at~1~AU
<br><code><i>body</i>._e</code> --- eccentricity
<br><code><i>body</i>._cepoch</code> --- epoch date for~<tt>_M</tt>
<br><code><i>body</i>._epoch</code> --- equinox year for <tt>_inc</tt>,
 <tt>_Om</tt>, and~<tt>_om</tt>
<br>(Magnitude parameters not yet supported.)

<dt><b>Hyperbolic Orbital Elements (<tt>HyperbolicBody</tt>)</b>
<dd><code><i>body</i>._epoch</code> --- equinox year for <tt>_inc</tt>,
 <tt>_Om</tt>, and~<tt>_om</tt>
<br><code><i>body</i>._ep</code> --- epoch of perihelion
<br><code><i>body</i>._inc</code> --- inclination in degrees
<br><code><i>body</i>._Om</code> --- longitude of ascending node in degrees
<br><code><i>body</i>._om</code> --- argument of perihelion in degrees
<br><code><i>body</i>._e</code> --- eccentricity
<br><code><i>body</i>._qp</code> --- perihelion distance in~AU
<br><code><i>body</i>._g, <i>body</i>._k</code> --- magnitude model
 coefficients
<br><code><i>body</i>._size</code> --- angular size in arcseconds at~1~AU

<dt><b>Parabolic Orbital Elements (<tt>ParabolicBody</tt>)</b>
<dd><code><i>body</i>._epoch</code> --- equinox year for <tt>_inc</tt>,
 <tt>_Om</tt>, and~<tt>_om</tt>
<br><code><i>body</i>._ep</code> --- epoch of perihelion
<br><code><i>body</i>._inc</code> --- inclination in degrees
<br><code><i>body</i>._Om</code> --- longitude of ascending node in degrees
<br><code><i>body</i>._om</code> --- argument of perihelion in degrees
<br><code><i>body</i>._qp</code> --- perihelion distance in~AU
<br><code><i>body</i>._g, <i>body</i>._k</code> --- magnitude model
 coefficients
<br><code><i>body</i>._size</code> --- angular size in arcseconds at~1~AU

<dt><b>Earth Satellite Orbital Elements (<tt>EarthSatellite</tt>)</b>
<dd><code><i>body</i>._epoch</code> --- reference epoch
<br><code><i>body</i>._n</code> --- mean motion in revolutions per day
<br><code><i>body</i>._inc</code> --- inclination in degrees
<br><code><i>body</i>._raan</code> --- right ascension of ascending node
 in degrees
<br><code><i>body</i>._e</code> --- eccentricity
<br><code><i>body</i>._ap</code> --- argument of perigee at epoch in degrees
<br><code><i>body</i>._M</code> --- mean anomaly in degrees from perigee
 at epoch
<br><code><i>body</i>._decay</code> --- orbit decay rate in revolutions
 per day, per day
<br><code><i>body</i>._drag</code> --- object drag coefficient
 in per earth radii
<br><code><i>body</i>._orbit</code> --- integer orbit number of epoch
</dl>

</body>
</html>
